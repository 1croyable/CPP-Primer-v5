结合网上的回答：


C 语言中，术语副作用（side effect）是指对数据对象或者文件的修改。例如，以下语句

var = 99;

的副作用是把 var 的值修改成 99。对表达式求值也可能产生副作用，例如：

se = 100

对这个表达式求值所产生的副作用就是 se 的值被修改成 100。

序列点（sequence point）是指程序运行中的一个特殊的时间点，在该点之前的所有副作用已经结束，并且后续的副作用还没发生。

程序执行中存在一系列顺序点（时刻），语言保证一旦执行到达一个顺序点，
在此之前发生的所有修改（副作用）都必须实现（必须反应到随后对同一存储位置的访问中） ，
在此之后的所有修改都还没有发生。
在顺序点之间则没有任何保证。对 C/C++ 语言这类允许表达式有副作用的语言，顺序点的概念特别重要。

顺序点:
顺序点位于：
            1 每个完整表达式结束时。
完整表达式包括变量初始化表达式，表达式语句，return 语句的表达式，以及条件、循环和 switch 语句的控制表达式（for 头部有三个控制表达式）；
            2 运算符 &&、||、?: 和逗号运算符的第一个运算对象计算之后；
（注释：他们是短路求值的）
函数调用中对所有实际参数和函数名表达式（需要调用的函数也可能通过表达式描述（如后面要学到的lambda表达式））的求值完成之后（进入函数体之前）。

所以在 上一个顺序点 到下一个顺序点之间，所有的副作用都要实现，但实现的顺序就不一定了。

问题回答:
C/C++ 语言的做法完全是有意而为，其目的就是允许编译器采用任何求值顺序，
使编译器在优化中可以根据需要调整实现表达式求值的指令序列，以得到效率更高的代码。
像 Java 那样严格规定表达式的求值顺序和效果，不仅限制了语言的实现方式，
还要求更频繁的内存访问（以实现副作用），这些可能带来可观的效率损失。
应该说，在这个问题上，C/C++和 Java 的选择都贯彻了它们各自的设计原则，各有所获
（C/C++ 潜在的效率，Java 更清晰的程序行为），当然也都有所失。
还应该指出，大部分程序设计语言实际上都采用了类似 C/C++的规定。

C/C++ 语言的规定告诉我们，任何依赖于特定计算顺序、依赖于在顺序点之间实现修改效果的表达式，其结果都没有保证。
程序设计中应该贯彻的规则是：如果在任何“完整表达式”（形成一段由顺序点结束的计算）里存在对同一“变量”的多个引用，
那么表达式里就不应该出现对这一“变量”的副作用。否则就不能保证得到预期结果。
举个例子：
一个很常见的错误：

int x = 1, y;
y = x++ + x++;

这里 y = x++ + x++ 是完整表达式，而 x++ 是它的子表达式。
这个完整表达式运算结束的那一点是一个序列点，int x = 1, y; 中的 ; 也是一个序列点。
也就是说，x++ + x++ 位于两个序列点之间。
标准规定，在两个序列点之间，一个对象所保存的值最多只能被修改一次。
但是我们清楚可以看到，上面这个例子中，x 的值在两个序列点之间被修改了两次。
这显然是错误的！这段代码在不同的编译器上编译可能会导致 y 的值有所不同。比较常见的结果是 y 的值最后被修改为 2 或者 3。