------------------------------------------------2.19
指针是对象（即指针有自己的一份内存空间，有自己的地址值），引用不是。

所以指针也可以被其他指针指向，指针也可以被引用。指针也无需在定义时赋初值。

---------------------------------------------2.20
将i平方后给i

------------------------------------------------2.21
int i = 0;

double* dp = &i;不合法，指针类型和对象类型要严格匹配（除了之后学到的继承关系下的特例情况和底层const指针的情况）
int *ip = i;不合法，右边不是地址
int *p = &i;合法


----------------------------------2.22
if(p)检查p是否为空
if(*p)检查p指向的对象，比如对象的值是0，则if不会执行

------------------------------------2.23
不行，指针储存的地址无法判断这个地址的对象是否合法，他无法判断自己所指对象怎么样。
后面会学到C++有智能指针，它们可以检查指向的对象是否合法，
有时候对象已经被销毁了，但是指针仍然指向那个内存，甚至那个内存空间也被释放了，这个指针肯定指向的是不合法的，但是指针自己不知道。

-------------------------------2.24
int i = 42;

void *p = &i; 合法。
void指针可以指向任何对象，但是由于我们不清楚它指向了什么，它的操作也被限制。比如作为函数的输入和输出（如19.1.1节对operator new等运算符的重载）。
另外void指针可以通过static_cast强制转换，来得到我们知道的指针，比如double*，这个在144也有讲。

long *lp = &i;非法，指针的类型和所指对象的类型应该严格匹配